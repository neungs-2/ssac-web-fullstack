# **Chapter 25. 클래스**

## Index

[25.1 클래스는 문법적 설탕인가?](#1)<br>
[25.2 클래스 정의](#2)<br>
[25.3 클래스 호이스팅](#3)<br>
[25.4 인스턴스 생성](#4)<br>
[25.5 메서드](#5)<br>
[25.6 클래스의 인스턴스 생성 과정](#5)<br>
[25.7 프로퍼티](#5)<br>
[25.8 상속에 의한 클래스 확장](#5)<br>

<br>

---

## **25.1 클래스는 문법적 설탕인가?**<a id="1"></a>

- ES6에서 도입된 새로운 객체 생성 매커니즘
  - 이전에도 생성자 함수와 프로토타입을 통해 OOP구현은 가능했음

<br>

**_생성자 함수와 클래스 차이_**

- **호출 시 `new` 연산자**
- 클래스는 `new` 연산자 없이 호출 시 에러
- 생성자 함수를 `new`연산자 없이 호출 시 일반 함수로서 호출
- **`extend`와 `super`키워드**
  - 클래스는 해당 키워드 지원
  - 생성자 함수는 해당 키워드 지원하지 않음
- **호이스팅 여부**
  - 클래스는 호이스팅이 발생하지 **않는 것처럼** 동작
  - 생성자 함수는 호이스팅 동작
    - 함수 선언문으로 정의 시 **함수 호이스팅**
    - 함수 표현식으로 정의 시 **변수 호이스팅**
- **[[Enumerable]]**
  - 클래스는 constructor, 프로토타입 메서드, 정적 메서드의 프로퍼티 어트리뷰트 [[Enumerable]] 값이 false (--> 열거 불가)

<br>

**_생성자 함수와 클래스 공통점_**

- 둘 다 프로토타입 기반의 객체지향을 구현

---

<br>

## **25.2 클래스 정의**<a id="2"></a>

- 클래스는 `class`키워드를 사용하여 정의
- **파스칼 케이스** 사용하는 것이 관례
- 클래스는 **일급객체(함수)**
  - 익명/기명 표현식으로 정의 가능
- 클래스 몸체에 선언 가능한 **메서드 종류** 3가지
  - constructor(생성자)
  - 프로토타입 메서드
  - 정적 메서드

```js
//클래스 선언문
class Person {}

// 기명 클래스 표현식
const Person = class {};

// 익명 클래스 표현식
const Person = class MyClass {};

// 예시
class Person {
  // 생성자
  constructor(name) {
    this.name = name; // name 프로퍼티는 public
  }

  // 프로토타입 메서드
  sayHi() {
    console.log(`Hi. My name is ${this.name}`);
  }

  //정적 메서드
  static sayHello() {
    console.log('Hello');
  }
}

// 인스턴스 생성
const me = new Person('Lee');

//인스턴스 프로퍼티 참조
console.log(me.name);

//프로토타입 메서드 호출
me.sayHi();

//정적 메서드 호출
Person.sayHello();
```

<br>

**_함수 정의 방식 비교_**

- 아래는 함수의 정의 방식이니 위의 클래스 정의 방식과 비교해볼 것

```js
//생성자 함수
function Person(name) {
  this.name = name;
}

// 프로토타입 메서드
Person.prototype.sayHi = function () {
  console.log(`Hi. My name is ${this.name}`);
};

// 정적 메서드
Person.sayHello = function () {
  console.log('Hello!');
};
```

---

<br>

## **25.3 클래스 호이스팅**<a id="3"></a>

- 클래스는 **함수**로 평가됨

<br>

- **클래스 선언문**
  - 함수 선언문처럼 소스코드 평가과정(런타임 이전)에 먼저 평가되어 함수 객체 생성
  - 클래스가 평가되어 생성된 함수 객체는 **constructor**
  - constructor는 생성자 함수로서 호출할 수 있는 함수
  - 따라서 **프로토타입**도 함께 생성됨
  - 단, 클래스 정의 이전에 참조 불가

<br>

- **클래스 호이스팅**
  - 클래스 정의 이전에 참조 불가하여 호이스팅이 없는 것 처럼 보임
  - 그러나 **클래스도 호이스팅 발생**
  - 단, `let`, `const`로 선언한 변수처럼 호이스팅
  - **일시적 사각지대(TDZ)** 발생하여 호이스팅 없는 것처럼 보임

<br>

**_호이스팅_**

- 런타임 이전에 먼저 실행 --> **호이스팅**
- var, let, const, function, function\*, class 키워드 이용한 식별자 모두 호이스팅 발생

---

<br>

## **25.4 인스턴스 생성**<a id="4"></a>

- 클래스 생성자 함수이며 `new` 연산자와 함께 호출되어 인스턴스 생성
  - 클래스는 인스턴스를 생성하는 것이 목적이므로 반드시 `new` 키워드 생성
- 클래스 **표현식**을 사용한 경우

  - 클래스를 가리키는 식별자를 사용하여 인스턴스를 생성
  - 클래스 이름은 클래스 내부에서만 사용되어 외부코드에서는 접근 불가 (기명 함수 표현식과 동일)

  ```js
  const Person = class Myclass {};
  const me = new Person(); // 인스턴스 생성 성공
  const me = new Myclass(); // 인스턴스 생성 실패
  ```

---

<br>

## **25.5 메서드**<a id="5"></a>

- 클래스 몸체에는 메서드만 선언 가능
- 메서드 종류
  - constructor
  - 프로토타입 메서드
  - 정적 메서드

<br>

### **Constructor**

- 인스턴스 생성 및 초기화를 위한 특수 메서드
- 클래스 정의가 평가 시 constructor의 동작을 하는 함수 객체 생성
- **_constructor_** 내부의 this는 클래스가 생성한 인스턴스 가리킴
  - 이는 생성자 함수와 동일

<br>

**_constructor와 생성자 함수 차이_**

- constructor는 클래스 내부 **1개만 존재** 가능
- constructor 생략 가능
  - 이때 빈 constructor가 암묵적으로 정의
- 프로퍼티 추가로 초기화된 인스턴스 생성하려면 constructor 내부에서 this에 인스턴스 프로퍼티 추가
- constructor는 별도의 **반환문을 갖지 않음**
  - `return`문 추가 시 **인스턴스는 반환되지 않음**

```js
class Person (name) {
  constructor() {
    this.name = name;
    this.address = 'Seoul';
  }
}

const me = new Person('Lee');
```

<br>

### **프로토타입 메서드**

- 생성자 함수에서는 프로토타입 메서드 추가를 위해 다음과 같이 정의
  - `Person.protptype.sayHi = function(){...};`
- 클래스에서는 `prototype` 프로퍼티에 메서드를 추가하지 않아도 기본적으로 프로토타입 메서드
  - 클래스가 생성한 인스턴스는 프로토타입 체인의 일원이 됨
  - 생성자 함수와 동일하지만 생성자 함수의 역할을 클래스가 함
  - 즉, 클래스는 생성자 함수처럼 **프로토타입 기반의 객체 생성 메커니즘**

```js
class Person {
  constructor(name) {
    this.name = name;
  }

  sayHi() {
    console.log(`Hi! My name is ${this.name}`);
  }
}

const me = new Person('Lee');
me.sayHi(); // Hi! My name is Lee
```

<br>

### **정적 메서드**

- 정적 메서드는 **인스턴스 생성 없이 호출** 가능한 메서드
- 셍성자 함수에서는 다음과 같이 명시적으로 메서드를 추가
  - `Person.sayHi = function(){...};`
- 클래스에서는 메서드에 `static`키워드를 추가하면 정적 메서드
- 정적 메서드는 클래스에 바인딩된 메서드가 됨
  - 인스턴스로 상속 불가능
  - 인스턴스 호출 불가능
- 정적 메서드는 클래스 정의가 평가되는 시점에 함수 객체가 생성되어 **인스턴스 생성 과정 불필요**
  - 인스턴스 호출이 아닌 **클래스로 호출**

```js
class Person {
  constructor(name) {
    this.name = name;
  }

  static sayHi() {
    console.log('Hi');
  }
}

Person.sayHi(); // Hi
```

<br>

### **정적 메서드와 프로토타입 메서드의 차이**

![image](https://user-images.githubusercontent.com/60606025/155476643-1c142ee2-b7a2-4f16-8d8d-472167c09745.png)

- **정적 메서드**
  - 클래스로 호출
  - 인스턴스 프로퍼티 참조 불가
  - 클래스에 바인딩 (Person에 바인딩)

<br>

- **프로토타입 메서드**
  - 인스턴스로 호출
  - 인스턴스 프로퍼티 참조 가능
  - 프로토타입에 바인딩 (Person.prototype 에 바인딩)
    <br>

### **클래스에서 정의한 메서드의 특징**

- `function` 키워드 생략한 메서드 축약 표현 사용
- 객체 리터럴과는 다르게 클래스 내 메서드 정의 시 콤마 필요 없음
- 암묵적으로 **strict mode** 적용
- `for...in`문, `Object.keys` 메서드 등으로 **열거 불가**
  - 프로퍼티 어트리뷰트 `[[Enumerable]]` 값이 false
- 내부 메서드 `[[Contructor]]`를 갖지 않는 non-constructor
  - `new` 연산자와 함께 호출 불가

---

<br>

## **25.6 클래스의 인스턴스 생성 과정**<a id="6"></a>

- `new` 연산자 없이 호출 불가
- `new` 연산자와 함께 호출 시 `[[Constructor]]`가 호출

<br>

### **인스턴스 생성 과정**

- **인스턴스 생성과 this 바인딩**
  - `new` 연산자와 함께 호출 시 빈 객체(인스턴스) 생성
  - 인스턴스의 프로토타입으로 클래스의 prototype 프로퍼티를 가리키는 객체 설정
  - 인스턴스는 `this`에 바인딩
- **인스턴스 초기화**

  - `constructor` 내부 코드 실행되어 this 바인딩된 인스턴스 초기화

- **인스턴스 반환**
  - 클래스 처리 완료 시 인스턴스가 바인딩된 `this`가 암묵적으로 반환

---

<br>

## **25.7 프로퍼티**<a id="7"></a>

---

<br>

## **25.8 상속에 의한 클래스 확장**<a id="8"></a>
