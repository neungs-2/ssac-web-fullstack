# **Chapter 25. 클래스**

## Index

[25.1 클래스는 문법적 설탕인가?](#1)<br>
[25.2 클래스 정의](#2)<br>
[25.3 클래스 호이스팅](#3)<br>
[25.4 인스턴스 생성](#4)<br>
[25.5 메서드](#5)<br>
[25.6 클래스의 인스턴스 생성 과정](#5)<br>
[25.7 프로퍼티](#5)<br>
[25.8 상속에 의한 클래스 확장](#5)<br>

<br>

---

## **25.1 클래스는 문법적 설탕인가?**<a id="1"></a>

- ES6에서 도입된 새로운 객체 생성 매커니즘
  - 이전에도 생성자 함수와 프로토타입을 통해 OOP구현은 가능했음

<br>

**_생성자 함수와 클래스 차이_**

- **호출 시 `new` 연산자**
- 클래스는 `new` 연산자 없이 호출 시 에러
- 생성자 함수를 `new`연산자 없이 호출 시 일반 함수로서 호출
- **`extend`와 `super`키워드**
  - 클래스는 해당 키워드 지원
  - 생성자 함수는 해당 키워드 지원하지 않음
- **호이스팅 여부**
  - 클래스는 호이스팅이 발생하지 **않는 것처럼** 동작
  - 생성자 함수는 호이스팅 동작
    - 함수 선언문으로 정의 시 **함수 호이스팅**
    - 함수 표현식으로 정의 시 **변수 호이스팅**
- **[[Enumerable]]**
  - 클래스는 constructor, 프로토타입 메서드, 정적 메서드의 프로퍼티 어트리뷰트 [[Enumerable]] 값이 false (--> 열거 불가)

<br>

**_생성자 함수와 클래스 공통점_**

- 둘 다 프로토타입 기반의 객체지향을 구현

---

<br>

## **25.2 클래스 정의**<a id="2"></a>

- 클래스는 `class`키워드를 사용하여 정의
- **파스칼 케이스** 사용하는 것이 관례
- 클래스는 **일급객체(함수)**
  - 익명/기명 표현식으로 정의 가능
- 클래스 몸체에 선언 가능한 **메서드 종류** 3가지
  - constructor(생성자)
  - 프로토타입 메서드
  - 정적 메서드

```js
//클래스 선언문
class Person {}

// 기명 클래스 표현식
const Person = class {};

// 익명 클래스 표현식
const Person = class MyClass {};

// 예시
class Person {
  // 생성자
  constructor(name) {
    this.name = name; // name 프로퍼티는 public
  }

  // 프로토타입 메서드
  sayHi() {
    console.log(`Hi. My name is ${this.name}`);
  }

  //정적 메서드
  static sayHello() {
    console.log('Hello');
  }
}

// 인스턴스 생성
const me = new Person('Lee');

//인스턴스 프로퍼티 참조
console.log(me.name);

//프로토타입 메서드 호출
me.sayHi();

//정적 메서드 호출
Person.sayHello();
```

<br>

**_함수 정의 방식 비교_**

- 아래는 함수의 정의 방식이니 위의 클래스 정의 방식과 비교해볼 것

```js
//생성자 함수
function Person(name) {
  this.name = name;
}

// 프로토타입 메서드
Person.prototype.sayHi = function () {
  console.log(`Hi. My name is ${this.name}`);
};

// 정적 메서드
Person.sayHello = function () {
  console.log('Hello!');
};
```

---

<br>

## **25.3 클래스 호이스팅**<a id="3"></a>

- 클래스는 **함수**로 평가됨

<br>

- **클래스 선언문**
  - 함수 선언문처럼 소스코드 평가과정(런타임 이전)에 먼저 평가되어 함수 객체 생성
  - 클래스가 평가되어 생성된 함수 객체는 **constructor**
  - constructor는 생성자 함수로서 호출할 수 있는 함수
  - 따라서 **프로토타입**도 함께 생성됨
  - 단, 클래스 정의 이전에 참조 불가

<br>

- **클래스 호이스팅**
  - 클래스 정의 이전에 참조 불가하여 호이스팅이 없는 것 처럼 보임
  - 그러나 **클래스도 호이스팅 발생**
  - 단, `let`, `const`로 선언한 변수처럼 호이스팅
  - **일시적 사각지대(TDZ)** 발생하여 호이스팅 없는 것처럼 보임

<br>

**_호이스팅_**

- 런타임 이전에 먼저 실행 --> **호이스팅**
- var, let, const, function, function\*, class 키워드 이용한 식별자 모두 호이스팅 발생

---

<br>

## **25.4 인스턴스 생성**<a id="4"></a>

- 클래스 생성자 함수이며 `new` 연산자와 함께 호출되어 인스턴스 생성
  - 클래스는 인스턴스를 생성하는 것이 목적이므로 반드시 `new` 키워드 생성
- 클래스 **표현식**을 사용한 경우

  - 클래스를 가리키는 식별자를 사용하여 인스턴스를 생성
  - 클래스 이름은 클래스 내부에서만 사용되어 외부코드에서는 접근 불가 (기명 함수 표현식과 동일)

  ```js
  const Person = class Myclass {};
  const me = new Person(); // 인스턴스 생성 성공
  const me = new Myclass(); // 인스턴스 생성 실패
  ```

---

<br>

## **25.5 메서드**<a id="5"></a>

---

<br>

## **25.6 클래스의 인스턴스 생성 과정**<a id="6"></a>

---

<br>

## **25.7 프로퍼티**<a id="7"></a>

---

<br>

## **25.8 상속에 의한 클래스 확장**<a id="8"></a>
