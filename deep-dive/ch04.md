# Chapter 4. 변수

## Index

[4.1 변수란 무엇인가? 왜 필요한가?](#41-변수란-무엇인가-왜-필요한가) <br>
[4.2 식별자](#42-식별자)<br>
[4.3 변수 선언](#43-변수-선언)<br>
[4.4 변수 선언의 실행 시점과 변수 호이스팅](#44-변수-선언의-실행-시점과-변수-호이스팅)<br>
[4.5 값의 할당](#45-값의-할당)<br>
[4.6 값의 재할당](#46-값의-재할당)<br>
[4.7 식별자 네이밍 규칙](#47-식별자-네이밍-규칙)

---

## 4.1 변수란 무엇인가? 왜 필요한가?

<br>

**변수**: 하나의 값을 저장하기 위해 확보한 메모리 공간 자체 또는 그 메모리 공간을 식별하기 위해 붙인 이름 <br>
--> 값의 위치를 가리키는 상징적인 이름

- 변수이름 : 메모리 공간에 저장된 값을 식별할 수 있는 고유한 이름
- 변수 값 : 변수에 저장된 값
- 할당 : 변수에 값을 저장하는 것
- 참조 : 변수에 저장된 값을 읽어 들이는 것
- 변수이름을 통해 참조 요청 시 JS 엔진이 매핑된 메모리 주소를 통해 메모리 공간에서 저장된 값을 반환
- 변수 이름은 심사숙고해서 지어야 함

  <br><br>

---

## 4.2 식별자

<br>

**식별자** : 어떤 값을 구별해서 식별할 수 있는 고유한 이름 (변수 이름 -> 식별자)

- 식별자는 값이 아닌 메모리 주소를 기억 (주소값은 1Byte)
- 선언에 의해 JS 엔진에 식별자의 존재를 알림

  <br><br>

---

## 4.3 변수 선언

<br>

**변수 선언** : 변수를 생성하는 것, 메모리 공간을 확보하고 변수 이름과 주소를 연결

- 변수를 사용하려면 반드시 선언이 필요
- var, let, const 키워드를 사용하여 변수를 선언
- 변수 선언 단계
  - 선언 단계: 변수 이름을 등록
  - 초기화 단계: 값을 저장하기 위한 메모리 공간을 확보
- JS는 초기화 시 암묵적으로 undefined를 할당하여 garbage value로부터 안전
- 선언하지 않은 식별자에 접근시 ReferenceError(참조 에러) 발생
  <br><br>

### Tip. 함수 레벨 스코프 vs 블록 레벨 스코프

- 함수 레벨 스코프
  - 함수 밖에서 선언한 변수는 전역변수
  - 함수 내에서 선언된 변수는 함수 내에서만 유효하며 함수 외부에서는 참조 불가
- 블록 레벨 스코프
  - 모든 코드 블록(함수, if 문, for 문, while 문, try/catch 문 등) 내에서 선언된 변수는 코드 블록 내에서만 유효하며 코드 블록 외부에서는 참조 불가
  - 자신이 정의된 블록과 그 하위 블록에서만 참조 가능한 지역 변수
    <br><br><br>

---

## 4.4 변수 선언의 실행 시점과 변수 호이스팅

<br>

**호이스팅**: 변수 선언문이 코드의 선두로 끌어 올려진 것처럼 동작하는 자바스크립트 고유의 특징

```javascript
console.log(score);

var score;
```

- 위의 코드에서 ReferenceError가 발생할 것 같지만 undefined가 출력
- 변수 선언이 런타임 이전 단계에서 먼저 실행되기 때문

  <br><br>

---

## 4.5 값의 할당

변수 할당 방법

```javascript
var score; //변수 선언
core = 80; // 값의 할당

var score = 80; //변수 선언 및 값의 할당을 하나의 문(Statement)으로 표현
```

<br>

- 변수 선언은 런타임 이전에 먼저 실행
- 값의 할당은 런타임에 실행
- 아래 코드에서 호이스팅과 런타임에서 값이 할당되어 첫번째 출력이 undefined

<br>

```javascript
console.log(score); //undefined

score = 80;
var score;

console.log(score); // 80
```

<br><br>

---

## 4.6 값의 재할당

- **재할당** : 현재 변수에 저장된 값을 버리고 새로운 값을 저장
- **상수** : 값을 한번만 할당할 수 있는 변수
- 재할당 시 기존의 메모리 공간이 아닌 **새로운 공간**에 값을 할당
- 변수와 연결이 해제된 값은 **가비지 콜렉터**에 의해 메모리에서 자동 해제

<br>

### Tip. 언매니지드 언어 vs 매니지드 언어

- **언매니지드 언어**
  - C언어처럼 저수준의 메모리 제어 기능 제공 (메모리 할당, 해제)
  - 개발자 역량에 따라 최적의 성능을 확보할 수 있지만 치명적인 오류를 생성할 수도 있음
- **매니지드 언어**

  - 메모리 관리 기능을 언어 차원에서 담당
  - 일정한 생산성을 확보할 수 있지만 성능 면에서 손실

    <br><br>

---

## 4.7 식별자 네이밍 규칙

- 식별자는 특수문자를 제외한 문자, 숫자, \_ , $ 포함 가능
- 단, 식별자는 숫자로 시작할 수 없음
- 예약어는 식별자로 사용 불가
- 대소문자 구분 가능
- 쉼표로 다수의 식별자를 한번에 선언 가능하지만 가독성이 나빠져 권장하지 않음
- 알파벳 외의 유니코드 문자는 권장하지 않음
- 의미가 명확한 변수 이름 설정

<br>

### 자바스크립트의 일반적인 네이밍 규칙

- 변수명, 함수명 : camelCase
- 생성자 함수, 클래스 이름 : PascalCase

<br>

### Naming Convention

```javascript
// 카멜 케이스(camelCase)
var firstName;

// 스네이크 케이스(snake_case)
var first_name;

// 파스칼 케이스(PascalCase)
var FirstName;

// 헝가리언 케이스(typeHungarianCase)
var strFirstName;
var $elem = document.getElementById('myId'); // DOM 노드
var observable$ = fromEvent(document, 'click'); // RxJS 옵저버블
```
