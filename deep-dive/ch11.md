# Chapter 11. 원시 값과 객체의 비교

## Index

[11.1 원시 값](#111-원시-값)<br>
[11.2 객체](#112-객체)

<br>

---

## Tip. 원시 타입 vs 객체 타입

- Primitive Type

  - 변경 불가능한 값
  - 변수 할당 시 확보된 메모리 공간에 실제 값이 저장
  - 원시 값을 갖는 변수를 다른 변수에 할당 시 원시 값이 복사되어 전달
    - 값에 의한 전달 = pass by value

- Object / Reference Type
  - 변경 가능한 값
  - 객체를 변수에 할당 시 확보된 메모리 공간에 참조 값이 저장
  - 객체를 가리키는 변수를 다른 변수에 할당 시 원본 참조 값이 복사되어 전달
    - 참조에 의한 전달 = pass by reference

<br>

---

## 11.1 원시 값

<br>

### 변경 불가능한 값

- 원시 값은 변경 불가능한 값, 읽기 전용
- 불변성, 데이터 신뢰성 보장
- 변경 불가능한 것은 **_변수_**가 아니라 **_값_**
- 원시 값 자체를 변경 불가
- 변수는 재할당을 통해 변수 값 변경 가능
  - **변수**
    - 하나의 값을 저장하기 위해 확보한 메모리 공간 자체
    - 혹은 그 메모리 공간을 식별하기 위한 이름
  - **값**
    - 변수에 저장된 데이터
    - 표현식이 평가되어 생성된 결과
  - **상수**
    - 재할당이 금지된 변수 (메모리 공간이 필요하니 변수)
- 변수에 새로운 원시 값 재할당
  - 원시 값을 변경하는 것이 아니라 새로운 메모리 공간에 새로운 원시 값을 할당
  - 변수는 새롭게 재할당한 원시 값 가리킴

<br>

### 문자열과 불변성

- JS는 **문자열 타입**을 **원시타입**으로 제공
  - 타 언어는 문자열이 기본타입 아님
- 문자열은 **유사 배열 객체**이며 **이터러블** --> 배열처럼 각 문자에 접근 가능
- 문자열은 원시타입이지만 객체처럼 사용 시 원시 값을 감싸는 래퍼 객체로 자동 변환

```js
var str = 'string';

// 인덱스를 통한 접근 가능
// 원시 값이므로 생성된 문자열 일부 변경 불가능
// 재할당은 가능
str[0] = 'T';

console.log(str); // string
```

<br>

- 유사배열 객체 (array-like object)
  - 배열처럼 인덱스로 프로퍼티 값에 접근 가능
  - length 프로퍼티 존재

<br>

### 값에 의한 전달

- 변수(copy)에 원시 값을 갖는 변수(origin)를 할당
  - 변수(origin)의 원시 값이 복사되어 변수(copy)에 할당
  - 혹은 파이썬처럼 참조하다가 변수(origin) 값 변경 시 할당될 수도 있음
  - ECMAScript에 명시되지 않음
  - 두 변수는 **같은 크기의 값**이지만 **다른 메모리 공간**에 저장 --> 별개의 값
  - 변수(origin) 값을 변경해도 변수(copy) 값은 불변

[정리]

```js
var copy = origin;
```

- 두 가지 평가 방식
  1. 새로운 origin을 생성하여 메모리 주소를 copy에 전달 --> 두 변수가 기억하는 메모리 주소 상이
  2. origin 변수 값의 메모리 주소를 그대로 전달 --> 두 변수가 기억하는 메모리 주소 동일
     <br>

엄격하게 표현하자면!!!

- `변수`에는 값이 전달되는 것이 아니라 `메모리 주소`가 전달
- 변수와 같은 `식별자`는 값이 아닌 `메모리 주소`를 기억
- 식별자는 메모리주소에 붙인 이름

<br>

**두 변수의 원시 값은 서로 다른 메모리 공간에 저장된 별개의 값이 되어 어느 한쪽에서 재할당을 통해 값을 변경하더라도 서로 간섭할 수 없음**

<br><br>

---

## 11.2 객체

- 객체
  - 프로퍼티의 개수가 미정
  - 동적으로 추가 및 삭제 가능
  - 프로퍼티 값 제약 없음
- 위의 특징으로 확보해야 할 메모리 공간 크기를 사전에 알 수 없음
- 객체 생성 및 프로퍼티 접근 등은 원시 값과 비교하자면 비용이 큼

<br>

### 자바스크립트 객체의 관리 방식

- 클래스 기반 객체지향 프로그래밍 언어(C++, Java)는 클래스를 기반으로 인스턴스 생성
  - 객체 생성 전 이미 프로퍼티와 메서드가 정해져 있음
  - 객체 생성 이후 프로퍼티 삭제, 추가 불가
- 자바스크립트는 클래스 없이 객체 생성
  - 객체 생성된 이후에도 동적 프로퍼티, 메서드 추가 가능
  - 사용성은 편하지만 성능 면에서 프로퍼티 접근에 비용이 더 많이 드는 방식

<br>

### 변경 가능한 값

- 객체는 변경 가능한 값
  - 재할당 없이 변경 가능 --> 프로퍼티 동적 추가, 갱신, 삭제 가능
- 객체를 할당한 변수가 기억하는 메모리 주소에 접근 시 참조 값(reference value)에 접근
  - 참조 값: 생성된 객체가 저장된 메모리 공간의 **주소**
- 객체는 재할당 비용이 크고 메모리 효율, 성능이 낮음
  - 크기가 매우 클 수 있고 크기가 일정하지 않음
  - 따라서 변경 가능한 값으로 설계
- 단점 : 여러 개의 식별자가 하나의 객체를 공유 가능

<br>

### 참조에 의한 전달

- 변수(origin)을 다른 변수(copy)에 할당 시 원본의 참조 값이 복사되어 전달
- 두 변수에 할당된 메모리 주소는 다르지만 동일한 참조 값 지님
  - 두 식별자가 하나의 객체 공유
- 한쪽에서 객체를 변경 시 서로 영향
- JS에서는 포인터가 없기 때문에 다른 언어에서의 참조에 의한 전달과 정확히 일치하지 않는 용어

```js
var person1 = {
  name: 'Lee',
};

var person2 = {
  name: 'Lee',
};

// === 일치 비교 연산자는 변수에 저장된 값을 타입 변환 없이 비교
console.log(person1 === person2); // false (참조값 비교)
consol.log(person1.name === person2.name); // true (원자값 비교 --> 값으로 평가될 수 있는 표현식이므로)
```

<br>

## 얕은 복사와 깊은 복사
***얕은 복사***
- **참조 복사**
  - 단순 객체 복제 --> 참조값(주소) 복사
  - 결국 같은 인스턴스를 가리킴
- **객체 복사**
  - 복합 객체(가장 바깥쪽)만 새로 생성, 중첩된 객체는 동일 인스턴스 가리킴

***깊은 복사***
- 모든 중첩 객체까지 완벽하게 복사
- lodash (_.clonedeep) 사용하거나 직접 구현

```js
const a = {id: 1, addr: {city: 'Seoul'}};

// 얕은 복사(참조 복사)
const c = a; // a와 b에는 같은 주소값이 들어있음

// 얕은 복사(객체 복사)
const sc = {...a} // a와 b는 다른 주소값을 갖지만 {city:seoul}을 결국 같은 인스턴스 가리킴

// 깊은 복사
const dc = _.clonedeep(a); // 아예 내부까지 새로운 인스턴스를 생성

```