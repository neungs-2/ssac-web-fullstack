# Chapter 12. 함수

## Index

[12.1 함수란?](#1)<br>
[12.2 함수를 사용하는 이유](#2)<br>
[12.3 함수 리터럴](#3)<br>
[12.4 함수 정의](#4)<br>
[12.5 함수 호출](#5)<br>
[12.6 참조에 의한 전달과 외부 상태의 변경](#6)<br>
[12.7 다양한 함수의 형태](#7)<br>

<br>

---

## 12.1 함수란?<a id="1"></a>

- **함수**: 일련의 과정을 문으로 구현하고 코드 블록으로 감싸서 하나의 실행 단위로 정의
- **함수의 구성요소**
  - 매개변수(parameter)
  - 인수(argument)
  - 반환값(return value)
- 함수 정의를 통해 생성
- 함수 호출을 통해 실행

---

<br>

## 12.2 함수를 사용하는 이유<a id="2"></a>

- 코드의 재사용
  - 유지보수의 편의성
  - 코드의 신뢰성 상승
  - 코드의 가독성 향상

---

<br>

## 12.3 함수 리터럴<a id="3"></a>

- 리터럴은 평가되어 값을 생성
- 객체 값으로 평가됨 -> **함수는 객체**
  - 일반 객체와의 차이점
    - 호출이 가능함
    - 함수 객체 고유의 프로퍼티 지님

함수 리터럴 구성요소

- **함수 이름**
  - 식별자 (식별자 네이밍 규칙 준수)
  - 함수 이름은 함수 몸체에서만 참조 가능
  - 이름 생략 가능(기명/무명.익명 함수)
- **매개변수 목록**
  - 0개 이상 (0개도 가능)
  - 순서에 의미 (인수가 순서대로 할당)
  - 식별자 네이밍 규칙 준수
- **함수 몸체**
  - 함수 호출 시 실행될 문을 정의한 코드 블록
  - 함수 호출에 의해 실행

```js
// 변수에 함수 리터럴 할당
var f = function add(x, y) {
  return x + y;
};
```

---

<br>

## 12.4 함수 정의<a id="4"></a>

- 변수는 '선언', 함수는 '정의'

**함수 정의 방식**

- 함수 선언문
- 함수 표현식
- Function 생성자 함수
- 화살표 함수(ES6)

<br>

### **_함수 선언문_**

- 함수 이름 생략 불가
- 표현식이 아닌 문
  - 표현식이 아니라 변수에 할당 불가
  - 할당하는 코드 실행시에는 JS 엔진이 함수 리터럴 표현식으로 해석
  - 값으로 평가되어야 하는 문맥에서는 리터럴 표현식으로 해석
- 선언문은 함수이름과 동일한 이름의 식별자 암묵적으로 생성
  - 따라서 함수이름을 함수 내부가 아닌 외부에서도 사용해서 호출 가능
  - 함수 리터럴로 해석 시 따로 변수에 할당하지 않으면 호출 불가능

```js
// 함수 선언문
function add(x, y) {
  return x + y;
}

add(
  2,
  5
)(
  // 7

  // 선언문 --> 리터럴 해석
  function add(x, y) {
    return x + y;
  }
); // 소괄호: 그룹 '연산자' --> 리터럴로 해석
add(2, 5); // Reference Error
```

<br>

### **_함수 표현식_**

- **일급 객체**: 값의 성질을 갖는 객체
- 함수는 일급 객체 --> 함수 리터럴로 생성한 함수 객체를 변수에 할당 가능
- 이런 정의 방식이 함수 표현식
- 함수 이름 생략 가능
  - 기명함수 표현식/ 익명함수 표현식

```js
var add = function (x, y) {
  return x + y;
};

add(2, 5); // 7
```

- \*표현식과 리터럴 예시
  - \*표현식: (var a=1) or (const a = function(){})
  - \*리터럴: 1 or function(){}

<br>

**함수 선언문과 표현식의 차이**

1. 함수 선언문은 표현식이 아닌 문
2. 생성 시점과 함수 호이스팅

- 함수 선언문
  - **함수 호이스팅**
    - 선언문 이전에 **호출 가능**
  - 선언문이므로 런타임 이전에 먼저 실행
  - 런타임 이전에 함수 객체가 먼저 생성
  - 런타임 시 식별자 할당까지 완료되어 **함수 호이스팅**

<br>

- 함수 표현식
  - **변수 호이스팅**
    - 선언문 이전 참조 시 undefined
    - 할당문 실행 이전에 **호출 불가능**
    - 할당문이 실행되는 런타임에 평가되어 비로소 함수 객체가 됨
  - var 키워드로 정의한 경우로 설명
  - 변수에 리터럴이 할당된 것이므로 **변수 호이스팅**

<br>

- \*생성 시점 : 인스턴스화 되는 시점
- 함수 선언문보다 표현식 사용을 권장

```js
console.dir(add); // f add (x,y)
console.dir(sub); // undefined

console.log(add(2, 5)); // 7
console.log(sub(2, 5)); // TypeError: sub is not a function

function add(x, y) {
  return x + y;
}

var sub = function (x, y) {
  return x - y;
};
```

<br>

**_Function 생성자 함수_**

- Function 생성자로 생성한 함수는 클로저를 생성하지 않음
- 일반적이지 않고 바람직하지 않은 방법

```js
var add = new Function('x', 'y', 'return x + y');
add(2, 5); // 7
```

<br>

**_화살표 함수_**

- ES6에서 도입된 방법
- 항상 익명 함수로 정의 (함수 이름은 없지만 식별자에 할당)
- 생성자 함수로 사용할 수 없음
- 기존 함수와 this 바인딩 방식 다름
- prototype 프로퍼티 없음
- argument 객체 생성하지 않음

```js
const add = (x, y) => x + y;
add(2, 5); // 7
```

---

<br>

## 12.5 함수 호출<a id="5"></a>

### **매개변수와 인수**

- 함수 실행에 필요한 값을 함수 외부에서 내부로 전달
- 매개변수를 통해 인수를 전달
- 인수는 값으로 평가 가능한 표현식 (개수, 타입 제한X)
- 매개변수의 스코프는 함수 내부

**_매개변수와 인수 개수 다른 경우_**

- 매개변수 > 인수
  - 인수 할당되지 않은 매개변수는 `undefined`
- 매개변수 < 인수
  - 순서대로 매개변수에 할당
  - 초과된 인수는 그냥 arguments 객체의 프로퍼티로 보관

<br>

### **인수 확인**

- JS 함수는 매개변수와 인수 개수가 일치하는지 확인X
- JS는 동적 타입 언어이므로 사전에 타입 미리 지정 X

<br>

**_기본값 할당 방법_**

- 단축 평가
- 매개변수 기본값 (ES6)

```js
// 단축 평가
function add(a, b) {
  a = a || 0;
  b = b || 0;
  return a + b;
}

// 매개변수 기본값
function add(a = 0, b = 0) {
  return a + b;
}
```

<br>

### **매개변수의 최대 개수**

- 매개변수 최대개수 제한은 없음
- 물리적인 한계는 존재
- 매개변수가 많다면?
  - 사용법 이해 어려움
  - 함수 변경 시 매개변수 순서에 따른 영향
  - 따라서 유지보수성 저하
- 3개 이하의 매개변수를 권장
- 다수의 매개변수가 필요한 경우 하나의 매개변수에 객체를 인수로 전달
- 외부 객체 함수 내부에서 조작 시 **부수효과** 주의

```js
$.ajax({
  method: 'POST',
  url: '/user',
  data: { id: 1, name: 'Lee' },
  cache: false,
});
```

<br>

### **반환문**
- 함수 호출은 표현식 --> **반환값으로 평가**
- 반환문 역할
  - 함수 실행 중단하고 빠져나감
  - return 키워드 뒤의 표현식을 평가해 반환
  - 지정하지 않을 시 `undefined`가 반환

---

<br>

## 12.6 참조에 의한 전달과 외부 상태의 변경<a id="6"></a>
***값에 의한 호출 (Call by Value)***
  - 값에 의한 전달 (Pass by Value)와 같은 동작 방식
  - 전달 받은 원시 타입 인수를 함수 몸체에서 변경 시
  - 원시 타입은 Immutable Value이므로 재할당을 통해 새로운 원시 값으로 교체
  - 따라서 전달한 원본 값은 변경 X

- ***참조에 의한 호출 (Call by Reference)***
  - 참조에 의한 전달(Pass by Reference)와 같은 동작 방식
  - 전달 받은 객체 타입 인수를 함수 몸체에서 변경 시
  - 객체 타입은 Mutable Value이므로 재할당 없이 할당된 객체를 변경
  - 따라서 전달한 객체값이 변경되는 **부수효과** 발생

```js
function changeVal (primitive, obj) {
  primitive += 100;
  obj.name = 'kim';
}

var num = 100;
var person = {name: 'Lee'};

changeVal(num, person);

console.log(num); // 100 --> 원본 유지
console.log(person); // {name: 'kim'} --> 원본 훼손
```

- 함수형 프로그래밍 --> **순수 함수**를 사용해 오류를 피하고 안정성 향상
  - 객체의 변경을 추적하기 위해 옵저버 패턴 등을 통한 대응이 필요
  - 객체를 불변 객체로 만들어 사용하는 방법도 가능
    - 깊은 복사를 통해 새로운 객체를 생성하고 쟇ㄹ당을 통해 교체

<br>

---

## 12.7 다양한 함수의 형태<a id="7"></a>

### **즉시 실행 함수** (IIFE; Immediately Invoked Function Expression)
- 함수 정의와 동시에 즉시 호출
- 단 한번만 호출되며 다시 호출 불가
- 일반적으로 익명함수 사용
- 그룹 연산자 (...)로 감싸야 함
  - 먼저 함수 리터럴을 평가해서 함수 객체를 생성하기 위해
  - 따라서 그룹연산자 이외의 연산자를 사용하는 것도 가능

- \*즉시 실행 함수가 변수에 할당 시 함수 실행 결과 (return)이 할당

```js
(function (x, y) {
  var a = x;
  var b = y;
  return a * b;
})(2, 3);
```

<br>

### **재귀 함수**
- 자기 자신을 호출(재귀 호출)하는 함수
- 반복되는 처리를 위해 사용
- 탈출 조건을 반드시 만들어야 함
  - 없으면 무한 호출로 Stack Overflow 빠짐
- 매번 함수 객체, 로컬 변수등 만들어야 해서 성능이 반복문보다 떨어짐
- 재귀함수 사용이 직관적으로 이해하기 쉬울 때만 사용

<br>

### **중첩 함수**
- 함수 내부에 정의된 함수
- 중첩함수는 외부함수 내부에서만 호출 가능

<br>

- /* ES6부터 if/for문 등 코드블록에서도 함수 정의 가능 --> 바람직하지 않음

<br>

### **콜백 함수**
- **고차 함수**(HOF): 외부에서 콜백 함수를 전달 받은 함수
- **콜백 함수**: 매개변수를 통해 다른 함수의 내부로 전달되는 함수
  - 중첩함수처럼 헬퍼 함수의 역할
  - 중첩함수는 교체하기 힘들지만 콜백함수는 교체 가능
  - 즉, 고차 함수는 콜백 함수를 자신의 일부분으로 합성
- 외부 정의된 함수를 콜백함수로 전달
  - 단 한번만 생성
- 익명의 리터럴을 콜백함수로 전달
  - 함수 호출될 때마다 콜백함수 생성

```js
function repeat (n, f) {
  for (var i = 0; i < n; i++) {
    f(i);
  }
}

// 정의된 함수를 콜백함수로 전달
function logOdds = function (i) {
  if (i%2) console.log(i);
}

repeat(5, logOdds);

// 익명의 리터럴을 콜백함수로 전달
repeat(5, function(i){
  if (i%2) console.log(i);
});
```

- \*비동기 I/O를 위해 노드에서는 콜백을 써야 함
---

<br>

### **순수 함수와 비순수 함수**
***순수 함수***
- 어떤 외부 상태에 의존하지도 않고 변경하지도 않는 함수
- **부수효과**가 없는 함수
- 동일 인수 전달 시 동일 값 반환
- 내부로 전달된 인수에게만 의존

***비순수 함수***
- 부수효과가 있는 함수
- 순수함수와 특성 반대

***함수형 프로그래밍***
- 순수함수와 보조함수의 조합을 통해 부수 효과를 최소화하여 **불변성**을 지향하는 프로그래밍 패러다임
- 로직 내의 조건문과 반복문을 제거
  - 복잡성 해결
- 변수 사용을 억제하거나 생명주기를 최소화
  - 상태 변경을 피해 오류를 최소화

<br>

- \*JS는 멀티 패러다임 언어
  - 객체지향 프로그래밍뿐만 아니라 함수형 프로그래밍 적극적으로 활용

---

<br>

## Note.

- 함수는 한번에 하나의 기능만
- 짧을 수록 좋음
- 함수 선언문은 표현식 x 문이므로 값이 아니라 그 자체로 객체
- 순수 함수로 코드를 작성하는 것이 좋다!!!

<br>

### 호이스팅

- 변수 호이스팅
  - 함수 표현식
  - let 호이스팅 시 블록 스코프인 것 잊지 말 것
    - let 맨 위에 선언, 맨 아래 선언하면 블록스코프 적용되는 것이 다름
- 함수 호이스팅
  - 함수 선언문
- 변수, 함수 호이스팅은 먼저 쓴 코드 순서로 실행
- JS 는 컴파일 언어가 아니기 때문에 평가단계 거침
  - 컴파일처럼 메모리를 확보, 오류 잡는 과정
- const는 재할당이 되지 않기 때문에 (static) 선언과 동시에 할당!! (JS엔진마다 상이함)
  - 그냥 코딩 오류뿐만 아니라 const가 JS 엔진 측면에서도 유리함
  - static 영역 = cache 영역
  - heap 영역은 Garbage collection이 돌기 때문에 변경
- 평가 시 function f(..){...}에서 {...} 부분은 평가하지 않음 --> 비동기 I/O
