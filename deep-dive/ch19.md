# Chapter 19. 프로토타입

<br>

## Index

[19.1 객체지향 프로그래밍](#191-객체지향-프로그래밍)<br>
[19.2 상속과 프로토타입](#192-상속과-프로토타입)<br>
[19.3 프로토타입 객체](#193-프로토타입-객체)<br>
[19.4 리터럴 표기법에 의해 생성된 객체의 생성자 함수와 프로토타입](#194-리터럴-표기법에-의해-생성된-객체의-생성자-함수와-프로토타입)<br>
[19.5 프로토타입의 생성 시점](#195-프로토타입의-생성-시점)<br>
[19.6 객체 생성 방식과 프로토타입의 결정](#196-객체-생성-방식과-프로토타입의-결정)<br>
[19.7 프로토타입 체인](#197-프로토타입-체인)<br>
[19.8 오버라이딩과 프로퍼티 섀도잉](#198-오버라이딩과-프로퍼티-섀도잉)<br>
[19.9 프로토타입의 교체](#199-프로토타입의-교체)<br>
[19.10 instanceof 연산자](#1910-instanceof-연산자)<br>
[19.11 직접 상속](#1911-직접-상속)<br>
[19.12 정적 프로퍼티/메서드](#1912-정적-프로퍼티/메서드)<br>
[19.13 프로퍼티 존재 확인](#1913-프로퍼티-존재-확인)<br>
[19.14 프로퍼티 열거](#1914-프로퍼티-열거)

---

## 19.1 객체지향 프로그래밍

<br>

- **추상화**
  - 다양한 속성 중 프로그램에 필요한 속성만 간추려 내어 표현하는 것
- **객체**
  - 속성을 통해 여러 개의 값을 하나의 단위로 구성한 복합적인 자료구조
  - 상태 데이터(프로퍼티)와 동작(메서드)을 하나의 논리적인 단위로 묶은 복합적인 자료구조

<br><br>

---

## 19.2 상속과 프로토타입

<br>

- **상속**
  - 어떤 객체의 프로퍼티 또는 메서드를 다른 객체가 상속 받아 그대로 사용
  - 불필요한 중복 제거
    - 생성자 함수의 인스턴스들은 동일 내용의 메서드를 중복 생성, 중복 소유
    - 불필요한 메모리 낭비
    - 퍼포먼스 악영향
  - 생성자 함수가 생성한 모든 인스턴스는 자신의 프로토타입 (상위 부모 객체)의 모든 프로퍼티, 메서드 상속
    - 동일 메서드, 프로퍼티 상속으로 다른 인스턴스들과 공유하여 사용
    - ex) function Circle (...){...}의 인스턴스들은 Circle.prototype 상속

<br><br>

---

## 19.3 프로토타입 객체

<br>

- **프로토타입 객체**
  - 어떤 객체의 상위(부모) 객체 역할을 하는 객체
  - 상속 구현을 위해 사용

<br>

- **[[Prototype]]**
  - 모든 객체는 [[Prototype]] 이라는 내부 슬롯 지님
  - 객체 생성 방식에 따라 프로토타입 결정되고 [[Prototype]]에 저장
  - [[Prototype]] 내부 슬롯에는 직접 접근 불가

<br>

- **\_\_proto\_\_**
  - \_\_proto\_\_ 접근자 프로퍼티를 통해 자신의 프로토타입([[Prototype]]이 가리키는 프로토타입)에 간접적으로 접근
  - \_\_proto\_\_ 접근자 프로퍼티는 객체가 직접 소유하는 것이 아닌 Object.prototype의 프로퍼티를 상속하여 사용
  - \_\_proto\_\_를 직접 사용하는 것은 권장하지 않음
    - 사용불가능한 객체가 존재하기 때문
      - ex) Object 생성자의 인스턴스는 프로토타입 체인의 종점
  - `Object.getPrototypeOf` & `Object.setPrototypeOf` 메서드 권장

<br>

- **constructor**
  - 프로토타입은 constructor 프로퍼티를 통해 생성자 함수에 접근
  - 모든 프로토타입은 constructor 지님
  - 따라서 프로토타입을 상속받는 인스턴스도 사용 가능

<br>

- **prototype**
  - 생성자 함수는 자신의 prototype 프로퍼티를 통해 프로토타입에 접근
  - 함수 객체만이 소유함
  - 일반 함수는 객체를 생성하지 않기 때문에 의미 없음

|                | constructor | constructor |   non-constructor   |
| :------------: | :---------: | :---------: | :-----------------: |
|                | 생성자 함수 |  일반함수   | 화살표 함수, 메서드 |
| prototype 여부 |      O      |      O      |          X          |

<br><br>

- **\_\_proto\_\_** 와 **prototype** 의 차이
  - 동일한 프로토타입을 가리키지만 사용하는 주체가 다름

|       구분        |    소유     |        값         |  사용주체   |                                사용목적                                |
| :---------------: | :---------: | :---------------: | :---------: | :--------------------------------------------------------------------: |
| **\_\_proto\_\_** |  모든 객체  | 프로토타입의 참조 |  모든 객체  |                  객체가 자신의 프로토타입에 접근,교체                  |
|   **prototype**   | constructor | 프로토타입의 참조 | 생성자 함수 | 생성자 함수가 자신이 생성할 인스턴스의 프로토타입을 할당하기 위해 사용 |

<br><br>

![image](https://user-images.githubusercontent.com/60606025/132664832-ce772d32-e3b4-4111-b799-bd0fc5210f62.png)

<br><br>

---

## 19.4 리터럴 표기법에 의해 생성된 객체의 생성자 함수와 프로토타입

<br>

- **객체 리터럴에 의해 생성**된 객체는 Object **생성자 함수가 생성**한 객체 아님
  - 추상 연산 OrdinaryObjectCreate를 호출하여 빈 객체를 생성하는 점 동일
  - 세부 내용에서 차이 존재 ( new.target 확인, 프로퍼티 추가하는 처리)
- 프로토타입과 생성자 함수는 단독 존재 불가, 언제나 쌍으로 존재
- 프로토타입의 constructor 프로퍼티를 통해 연결된 생성자 함수를 리터럴 표기법으로 만든 객체를 생성한 함수로 생각해도 크게 무리는 없음

  > - 엄밀하게 말하면 리터럴 방식은 생성자 함수가 생성하는 것은 아니지만 큰 틀에서 볼때 같다고 해도 무관<br>

  > - 객체는 리터럴 표기법, 생성자 함수에 의해 생성되므로 결국 모든 객체는 생성자 함수와 연결

<br><br>

---

## 19.5 프로토타입의 생성 시점

<br>

- 프로토타입은 생성자 함수가 생성되는 시점에 더불어 생성
  - 프로토타입과 생성자 함수는 쌍으로 존재

<br>

### 사용자 정의 생성자 함수와 프로토타입 생성 시점

<br>

- 생성자 함수로 호출 가능한 함수(constructor)는 함수 정의가 평가되어 함수 객체를 생성하는 시점에 프로토타입도 생성
- 함수 선언문은 런타임 이전에 먼저 실행
  - 이때 프로토타입도 생성
  - 생성자 함수 prototype 프로퍼티에 바인딩

<br>

### 빌트인 생성자 함수와 프로토타입 생성 시점

<br>

- 모든 빌트인 생성자 함수는 전역 객체가 생성되는 시점에 생성
  - 이때 프로토타입 생성
  - 빌트인 생성자 함수의 prototype 프로퍼티에 바인딩

<br>

> - 객체 생성 이전에 생성자 함수와 프로토타입은 이미 객체화되어 존재<br>
> - 이후 생성자 함수 or 리터럴 표기법으로 객체 생성 시 프로토타입은 생성된 객체의 [[Prototype]] 내부 슬롯에 할당

<br><br>

---

## 19.6 객체 생성 방식과 프로토타입의 결정

<br>

- 객체 생성 방식
  - 객체 리터럴
  - Object 생성자 함수
  - 생성자 함수
  - Object.create 메서드
  - 클래스 (ES6)

<br>

- 프로토타입은 추상 연산 OrdinaryObjectCreate에 전달되는 인수에 의해 결정
  - 인수는 객체 생성 시점에 객체 생성 방식에 의해 결정

<br>

### **객체 리터럴**로 생성된 객체의 프로토타입

- 프로토타입 : Object.prototype
- Object.prototype을 상속
  - constructor 프로퍼티, hasOwnProperty 메서드 사용 가능

<br>

### **Object 생성자 함수**로 생성된 객체의 프로토타입

- 프로토타입 : Object.prototype
- Object.prototype을 상속
  - constructor 프로퍼티, hasOwnProperty 메서드 사용 가능

<br>

- 객체 리터럴 방식과 비교
  - 공통점 : 동일한 구조
  - 차이점 : 프로퍼티를 추가하는 방식
    - 객체 리터럴 방식은 객체 리터럴 내부에 프로퍼티 추가
    - Object 생성자 함수 방식은 빈 객체 생성한 이후 프로퍼티 추가

<br>

### **생성자 함수**로 생성된 객체의 프로토타입

- 프로토타입 : 생성자 함수의 prototype 프로퍼티에 바인딩되어 있는 객체
- 프로토타입의 프로퍼티는 constructor 뿐

<br>

- 프로토타입은 객체 --> 프로퍼티 추가/삭제 가능
  - 상속 시킬 프로퍼티, 메서드를 프로퍼티에 추가해서 자식 객체가 사용 가능

<br><br>

---

## 19.7 프로토타입 체인

<br>

- 프로토타입의 프로토타입 : Object.prototype --> **프로토타입 체인의 종점**
  - Object.prototype의 프로토타입 ([[Prototype]] 내부슬롯 값) : **null**
  - Object.prototype에도 프로퍼티 검색 안되는 경우 **undefined** 반환
    - 에러 발생 안하는 것 주의

<br>

- **프로토타입 체인**
  - 해당 객체에 접근하려는 프로퍼티 없으면 [[Prototype]] 내부 슬롯 참조를 따라 순차적으로 검색
  - 상속과 프로퍼티/메서드 검색을 위한 메커니즘

<br>

- **스코프 체인**
  - 식별자 검색을 위한 메커니즘

<br>

- 두 체인이 협력하여 식별자, 프로퍼티 검색
  <br><br>

---

## 19.8 오버라이딩과 프로퍼티 섀도잉

<br>

<br><br>

---

## 19.9 프로토타입의 교체

<br>

<br><br>

---

## 19.10 instanceof 연산자

<br>

<br><br>

---

## 19.11 직접 상속

<br>

<br><br>

---

## 19.12 정적 프로퍼티/메서드

<br>

<br><br>

---

## 19.13 프로퍼티 존재 확인

<br>

<br><br>

---

## 19.14 프로퍼티 열거

<br>
