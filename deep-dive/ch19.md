# Chapter 19. 프로토타입

<br>

## Index

[19.1 객체지향 프로그래밍](#191-객체지향-프로그래밍)<br>
[19.2 상속과 프로토타입](#192-상속과-프로토타입)<br>
[19.3 프로토타입 객체](#193-프로토타입-객체)<br>
[19.4 리터럴 표기법에 의해 생성된 객체의 생성자 함수와 프로토타입](#194-리터럴-표기법에-의해-생성된-객체의-생성자-함수와-프로토타입)<br>
[19.5 프로토타입의 생성 시점](#195-프로토타입의-생성-시점)<br>
[19.6 객체 생성 방식과 프로토타입의 결정](#196-객체-생성-방식과-프로토타입의-결정)<br>
[19.7 프로토타입 체인](#197-프로토타입-체인)<br>
[19.8 오버라이딩과 프로퍼티 섀도잉](#198-오버라이딩과-프로퍼티-섀도잉)<br>
[19.9 프로토타입의 교체](#199-프로토타입의-교체)<br>
[19.10 instanceof 연산자](#1910-instanceof-연산자)<br>
[19.11 직접 상속](#1911-직접-상속)<br>
[19.12 정적 프로퍼티/메서드](#1912-정적-프로퍼티/메서드)<br>
[19.13 프로퍼티 존재 확인](#1913-프로퍼티-존재-확인)<br>
[19.14 프로퍼티 열거](#1914-프로퍼티-열거)

---

## 19.1 객체지향 프로그래밍

<br>

- **추상화**
  - 다양한 속성 중 프로그램에 필요한 속성만 간추려 내어 표현하는 것
- **객체**
  - 속성을 통해 여러 개의 값을 하나의 단위로 구성한 복합적인 자료구조
  - 상태 데이터(프로퍼티)와 동작(메서드)을 하나의 논리적인 단위로 묶은 복합적인 자료구조

<br><br>

---

## 19.2 상속과 프로토타입

<br>

- **상속**
  - 어떤 객체의 프로퍼티 또는 메서드를 다른 객체가 상속 받아 그대로 사용
  - 불필요한 중복 제거
    - 생성자 함수의 인스턴스들은 동일 내용의 메서드를 중복 생성, 중복 소유
    - 불필요한 메모리 낭비
    - 퍼포먼스 악영향
  - 생성자 함수가 생성한 모든 인스턴스는 자신의 프로토타입 (상위 부모 객체)의 모든 프로퍼티, 메서드 상속
    - 동일 메서드, 프로퍼티 상속으로 다른 인스턴스들과 공유하여 사용
    - ex) function Circle (...){...}의 인스턴스들은 Circle.prototype 상속

<br><br>

---

## 19.3 프로토타입 객체

<br>

- **프로토타입 객체**
  - 어떤 객체의 상위(부모) 객체 역할을 하는 객체
  - 상속 구현을 위해 사용

<br>

- **[[Prototype]]**
  - 모든 객체는 [[Prototype]] 이라는 내부 슬롯 지님
  - 객체 생성 방식에 따라 프로토타입 결정되고 [[Prototype]]에 저장
  - [[Prototype]] 내부 슬롯에는 직접 접근 불가

<br>

- **\_\_proto\_\_**
  - \_\_proto\_\_ 접근자 프로퍼티를 통해 자신의 프로토타입([[Prototype]]이 가리키는 프로토타입)에 간접적으로 접근
  - \_\_proto\_\_ 접근자 프로퍼티는 객체가 직접 소유하는 것이 아닌 Object.prototype의 프로퍼티를 상속하여 사용
  - \_\_proto\_\_를 직접 사용하는 것은 권장하지 않음
    - 사용불가능한 객체가 존재하기 때문
      - ex) Object 생성자의 인스턴스는 프로토타입 체인의 종점
  - `Object.getPrototypeOf` & `Object.setPrototypeOf` 메서드 권장

<br>

- **constructor**
  - 프로토타입은 constructor 프로퍼티를 통해 생성자 함수에 접근
  - 모든 프로토타입은 constructor 지님
  - 따라서 프로토타입을 상속받는 인스턴스도 사용 가능

<br>

- **prototype**
  - 생성자 함수는 자신의 prototype 프로퍼티를 통해 프로토타입에 접근
  - 함수 객체만이 소유함
  - 일반 함수는 객체를 생성하지 않기 때문에 의미 없음

|                | constructor | constructor |   non-constructor   |
| :------------: | :---------: | :---------: | :-----------------: |
|                | 생성자 함수 |  일반함수   | 화살표 함수, 메서드 |
| prototype 여부 |      O      |      O      |          X          |

<br><br>

- **\_\_proto\_\_** 와 **prototype** 의 차이
  - 동일한 프로토타입을 가리키지만 사용하는 주체가 다름

|       구분        |    소유     |        값         |  사용주체   |                                사용목적                                |
| :---------------: | :---------: | :---------------: | :---------: | :--------------------------------------------------------------------: |
| **\_\_proto\_\_** |  모든 객체  | 프로토타입의 참조 |  모든 객체  |                  객체가 자신의 프로토타입에 접근,교체                  |
|   **prototype**   | constructor | 프로토타입의 참조 | 생성자 함수 | 생성자 함수가 자신이 생성할 인스턴스의 프로토타입을 할당하기 위해 사용 |

<br><br>

![image](https://user-images.githubusercontent.com/60606025/132664832-ce772d32-e3b4-4111-b799-bd0fc5210f62.png)

<br><br>

---

## 19.4 리터럴 표기법에 의해 생성된 객체의 생성자 함수와 프로토타입

<br>

- **객체 리터럴에 의해 생성**된 객체는 Object **생성자 함수가 생성**한 객체 아님
  - 추상 연산 OrdinaryObjectCreate를 호출하여 빈 객체를 생성하는 점 동일
  - 세부 내용에서 차이 존재 ( new.target 확인, 프로퍼티 추가하는 처리)

<br>

- 프로토타입과 생성자 함수는 단독 존재 불가, 언제나 쌍으로 존재
- 프로토타입의 constructor 프로퍼티를 통해 연결된 생성자 함수를 리터럴 표기법으로 만든 객체를 생성한 함수로 생각해도 크게 무리는 없음

  > - 엄밀하게 말하면 리터럴 방식은 생성자 함수가 생성하는 것은 아니지만 큰 틀에서 볼때 같다고 해도 무관<br>

  > - 객체는 리터럴 표기법, 생성자 함수에 의해 생성되므로 결국 모든 객체는 생성자 함수와 연결

<br><br>

---

## 19.5 프로토타입의 생성 시점

<br>

- 프로토타입은 생성자 함수가 생성되는 시점에 더불어 생성
  - 프로토타입과 생성자 함수는 쌍으로 존재

<br>

### 사용자 정의 생성자 함수와 프로토타입 생성 시점

<br>

- 생성자 함수로 호출 가능한 함수(constructor)는 함수 정의가 평가되어 함수 객체를 생성하는 시점에 프로토타입도 생성
- 함수 선언문은 런타임 이전에 먼저 실행
  - 이때 프로토타입도 생성
  - 생성자 함수 prototype 프로퍼티에 바인딩

<br>

### 빌트인 생성자 함수와 프로토타입 생성 시점

<br>

- 모든 빌트인 생성자 함수는 전역 객체가 생성되는 시점에 생성
  - 이때 프로토타입 생성
  - 빌트인 생성자 함수의 prototype 프로퍼티에 바인딩

<br>

> - 객체 생성 이전에 생성자 함수와 프로토타입은 이미 객체화되어 존재<br>
> - 이후 생성자 함수 or 리터럴 표기법으로 객체 생성 시 프로토타입은 생성된 객체의 [[Prototype]] 내부 슬롯에 할당

<br><br>

---

## 19.6 객체 생성 방식과 프로토타입의 결정

<br>

- 객체 생성 방식
  - 객체 리터럴
  - Object 생성자 함수
  - 생성자 함수
  - Object.create 메서드
  - 클래스 (ES6)

<br>

- 프로토타입은 추상 연산 OrdinaryObjectCreate에 전달되는 인수에 의해 결정
  - 인수는 객체 생성 시점에 객체 생성 방식에 의해 결정

<br>

### **객체 리터럴**로 생성된 객체의 프로토타입

- 프로토타입 : Object.prototype
- Object.prototype을 상속
  - constructor 프로퍼티, hasOwnProperty 메서드 사용 가능

<br>

### **Object 생성자 함수**로 생성된 객체의 프로토타입

- 프로토타입 : Object.prototype
- Object.prototype을 상속
  - constructor 프로퍼티, hasOwnProperty 메서드 사용 가능

<br>

- 객체 리터럴 방식과 비교
  - 공통점 : 동일한 구조
  - 차이점 : 프로퍼티를 추가하는 방식
    - 객체 리터럴 방식은 객체 리터럴 내부에 프로퍼티 추가
    - Object 생성자 함수 방식은 빈 객체 생성한 이후 프로퍼티 추가

<br>

### **생성자 함수**로 생성된 객체의 프로토타입

- 프로토타입 : 생성자 함수의 prototype 프로퍼티에 바인딩되어 있는 객체
- 프로토타입의 프로퍼티는 constructor 뿐

<br>

- 프로토타입은 객체 --> 프로퍼티 추가/삭제 가능
  - 상속 시킬 프로퍼티, 메서드를 프로퍼티에 추가해서 자식 객체가 사용 가능

<br><br>

---

## 19.7 프로토타입 체인

<br>

- 프로토타입의 프로토타입 : Object.prototype --> **프로토타입 체인의 종점**
  - Object.prototype의 프로토타입 ([[Prototype]] 내부슬롯 값) : **null**
  - Object.prototype에도 프로퍼티 검색 안되는 경우 **undefined** 반환
    - 에러 발생 안하는 것 주의

<br>

- **프로토타입 체인**
  - 해당 객체에 접근하려는 프로퍼티 없으면 [[Prototype]] 내부 슬롯 참조를 따라 순차적으로 검색
  - 상속과 프로퍼티/메서드 검색을 위한 메커니즘

<br>

- **스코프 체인**
  - 식별자 검색을 위한 메커니즘

<br>

- 두 체인이 협력하여 식별자, 프로퍼티 검색

  <br><br>

---

## 19.8 오버라이딩과 프로퍼티 섀도잉

<br>

- **프로퍼티 섀도잉** : 상속관계에 의해 프로퍼티가 가려지는 현상
- **오버라이딩** : 상위 클래스가 가진 메서드를 하위 클래스가 재정의하여 사용
- **오버로딩** : 함수 이름은 동일하지만 매개변수 타입, 개수가 다른 메서드를 구현
  - 매개변수에 의해 메서드를 구별하여 호출
  - JS는 오버로딩 지원하지 않지만 arguments 객체를 사용하여 구현 가능
- 프로토타입 메서드/프로퍼티와 같은 이름의 메서드/프로퍼티를 인스턴스에 추가 --> 오버라이딩
- 프로퍼티 섀도잉 발생

<br>

- 하위 객체를 통한 프로토타입 프로퍼티 변경,삭제 불가능
- get 엑세스 허용, set 엑세스 허용X
- 프로토타입에 직접 접근해야 함

<br><br>

---

## 19.9 프로토타입의 교체

<br>

- 프로토타입은 임의의 다른 객체로 변경 가능
  - 부모 객체인 프로토타입(상속 관계) 동적 변경 가능

<br>

### 생성자 함수에 의한 프로토타입의 교체

```js
const Person = (function () {
  // 생성자 함수
  function Person(name) {
    this.name = name;
  }

  // 생성자 함수의 prototype 프로퍼티를 통해 프로토타입을 교체
  Person.prototype = {
    constructor: Person, //** constructor 추가
    sayHello() {
      console.log('Hi ${this.name}');
    },
  };

  return Person;
})();

const me = new Person('Lee');
```

- 프로토타입 교체한 constructor 프로퍼티와 생성자 함수 간 연결 파괴
- me 객체 생성자 함수 검색 시 Person이 아닌 Object가 나옴
- 직접 constructor 프로퍼티 추가하여 복구 --> //\*\*부분 확인

<br>

### 인스턴스에 의한 프로토타입의 교체

```js
function Person(name) {
  this.name = name;
}

// 프로토타입으로 교체할 객체
const parent = {
  sayHello() {
    console.log('Hi ${this.name}');
  },
};

// 프로토타입 교체
Object.setPrototype(me, parent);

me.sayHello();
```

- 인스턴스의 `__proto__` 또는 `Object.setPrototypeOf` 를 통해 프로토타입 교체 가능
- constructor 프로퍼티, 생성자 함수 간 연결 파괴
- 생성자 함수의 prototype 프로퍼티가 교체된 프로퍼티 안 가리킴
  - 생성자 함수에 의한 프로퍼티 교체 방법과의 차이

<br><br>

---

## 19.10 instanceof 연산자

<br>

- `<인스턴스> instanceOf <생성자 함수>`
- 우변의 생성자 함수의 prototype에 바인딩된 객체가 **프로토타입 체인** 상에 존재하는지 확인

<br><br>

---

## 19.11 직접 상속

<br>

### Object.create 에 의한 직접 상속

- Object.create(프로토타입으로 지정할 객체, 프로퍼티를 갖는 객체)

```js
const myProto = { x: 10 };

const obj = Object.create(myProto, {
  y: { value: 20, writable: true, enumerable: true, configurable: true },
});
```

<br>

### 객체 리터럴 내부에서 **proto** 에 의한 직접 상속

- ES6에서는 객체 리터럴 내부에서 **proto** 접근자 프로퍼티를 사용하여 직접상속 구현

```js
const myProto = {x: 10};

const obj = {
  y: 20;
  __proto__: myProto
};
```

<br><br>

---

## 19.12 정적 프로퍼티/메서드

<br>

- **정적 프로퍼티/메서드** : 생성자 함수로 인스턴스를 생성하지 않아도 참조/호출할 수 있는 프로퍼티/메서드
- 생성자 함수 객체가 소유한 프로퍼티/메서드
- 인스턴스는 프로토타입 체인에 속한 (프로토타입의) 프로퍼티/메서드에 접근 가능
- 하지만 생성자 함수의 정적 프로퍼티/메서드에는 호출 불가능
- 인스턴스/프로토타입 메서드 내에서 this 사용 X --> 정적 메서드 변경 가능

```js
function Foo() {}

Foo.x = function () {
  //정적 메서드
  console.log('x');
};

Foo.x(); // 정적 메서드는 인스턴스 생성 없이 호출 가능
```

<br><br>

---

## 19.13 프로퍼티 존재 확인

<br>

### in 연산자

- 객체 내에 특정 프로퍼티 존재 여부 확인
- 상속받은 모든 프로토타입의 프로퍼티를 확인
- ex) `'toString' in person` --> true
- `Reflect.has(person, 'toString')` 도 in과 똑같이 동작

<br>

### Object.prototype.hasOwnProperty 메서드

- 객체 내에 특정 프로퍼티 존재 여부 확인
- 객체의 고유 프로퍼티만 true 반환
- 상속 받은 프로퍼티는 false 반환
- ex) `person.hasOwnProperty('toString')` --> false

<br><br>

---

## 19.14 프로퍼티 열거

<br>

### for ... in 문

- `for (변수선언문 in 객체) {...}`
- 객체의 모든 프로퍼티를 순회하며 열거(enumeration)
  - 객체의 프로퍼티 개수만큼 순회하며 선언한 변수에 프로퍼티 키 할당
  - 객체의 프로퍼티뿐만 아니라 **상속받은 프로퍼티 키까지 열거**
  - 단, **[[Enumerable]] 값이 true인 프로퍼티**만 열거 가능
  - 배열에서는 인덱스 값을 반환

```js
const person = {
  name: 'Lee',
  address: 'Seoul'
  __proto__: {age:20}
};

for (const key in person) {
  console.log(key + ':' + person[key]);
}
// name:Lee
// address:Seoul
// age: 20
```

> **for...in 문은 객체의 프로토타입 체인 상에 존재하는 모든 프로토타입의 프로퍼티 중 프로퍼티 어트리뷰트 [[Enumerable]] 값이 true인 프로퍼티를 순회하며 열거**

<br>

- 상속 받은 프로퍼티 제외하고 객체의 프로퍼티만 열거하려면 `Object.prototype.hasOwnProperty` 사용

```js
for (const key in person) {
  if (!person.hasOwnProperty(key)) continue;
  console.log(key + ':' + person[key]);
}
// name:Lee
// address:Seoul
```

<br>

- for ... in 문은 배열에서 인덱스 반환
  - 배열의 경우도 객체이므로 프로퍼티와 상속받은 프로퍼티 포함될 수 있음
  - 따라서 배열에서는 `for ... of` 문, 일반 `for`문, `Array.prototype.forEach` 메서드 사용

```js
const arr = [1, 2, 3];
arr.forEach((v) => console.log(v)); // 1 2 3
// forEach도 for...of 처럼 값 반환
```

<br>

### Object.keys/values/entries 메서드

- 객체의 고유 프로퍼티만 열거 시 for...in 문 등 보다 `Object.keys/values/entries` 권장
  - Object.keys : 객체 자신의 enumerable한 프로퍼티 키를 배열로 반환
  - Object.values : 객체 자신의 enumerable한 프로퍼티 값을 배열로 반환 (ES8 도입)
  - Object.entries : 객체 자신의 enumerable한 프로퍼티 [키, 값] 쌍을 배열로 반환 (ES8 도입)
